/*
 * farm.h
 *
 *  Created on: Aug 23, 2017
 *      Author: fabio
 */

#ifndef GRPPI_FF_FARM_H
#define GRPPI_FF_FARM_H

#ifdef GRPPI_FF

#include "parallel_execution_ff.h"

#include <ff/node.hpp>
#include <ff/farm.hpp>
#include <ff/allocator.hpp>
#include "ff_node_wrap.hpp"

namespace grppi {

/**
\addtogroup farm_pattern
@{
\addtogroup farm_pattern_ff FasfFlow parallel farm pattern
\brief FF parallel implementation of the \ref md_farm.
@{
*/

/**
\brief Invoke \ref md_farm on a data stream with FF parallel
execution with a generator and a consumer.
\tparam Generator Callable type for the generation operation.
\tparam Consumer Callable type for the consume operation.
\param ex FF parallel execution policy object.
\param generate_op Generator operation.
\param consume_op Consumer operation.
*/
template <typename Generator, typename Consumer>
void farm(parallel_execution_ff & ex, Generator generate_op,
		Consumer consume_op) {

	bool notnested = ff::outer_ff_pattern;
	ff::outer_ff_pattern = false;

	auto nw = ex.concurrency_degree();
	using emitterOutType  = typename std::result_of<Generator()>::type;

	// Consumer takes values of the result type of the Transformer. Since this interface
	// seems to be designed for identity farm, the consumer just consumes data generated by
	// the generator!
	using consumerOutType = typename std::result_of<Consumer(emitterOutType)>::type;


	std::unique_ptr<ff::ff_node> E = std::make_unique<ff::PMINode<void,emitterOutType,Generator>>(generate_op);

	std::vector<std::unique_ptr<ff::ff_node>> w;
	for(int i=0; i<nw; ++i)
		w.push_back( std::make_unique<ff::PMINode<emitterOutType,consumerOutType,Consumer> >(consume_op) );

	ff::ff_Farm<> farm( std::move(w), std::move(E) );

	farm.setFixedSize(true);
	farm.setInputQueueLength(nw*1);
	farm.setOutputQueueLength(nw*1);

	if(notnested) {
		farm.remove_collector(); // needed to avoid init errors!
		farm.run_and_wait_end();

		// check if ff_nodes need to be deleted
		// in case of nested pattern this don't work - to be fixed with unique_ptr
		//for(int i=0;i<p.num_threads;++i) delete w[i];
	}
}

template <typename Generator, typename Transformer, typename Consumer>
void farm(parallel_execution_ff & ex, Generator generate_op,
		Transformer transform_op , Consumer consume_op) {

	bool notnested = ff::outer_ff_pattern;
	ff::outer_ff_pattern = false;

	using generator_type     = typename std::result_of<Generator()>::type;
	using emitterOutType     = typename generator_type::value_type;
	using transformerOutType = typename std::result_of<Transformer(emitterOutType)>::type;
	// Consumer takes values of the result type of the Transformer.
	//using consumerOutType    = typename std::result_of<Consumer(transformerOutType)>::type;

	//using transformed_type = optional<transformeOutType>;

	auto nw = ex.concurrency_degree();

	// first stage
	std::unique_ptr<ff::ff_node> E = std::make_unique<ff::PMINode<void,emitterOutType,Generator>>(generate_op);
	// last stage
	std::unique_ptr<ff::ff_node> C = std::make_unique<ff::PMINode<void,transformerOutType,Consumer>>(consume_op);

	std::vector<std::unique_ptr<ff::ff_node>> w;
	for(int i=0; i<nw; ++i)
		w.push_back( std::make_unique<ff::PMINode<emitterOutType,transformerOutType,Transformer>>(transform_op) );

	ff::ff_Farm<> farm( std::move(w), std::move(E), std::move(C) );

	farm.setFixedSize(true);
	farm.setInputQueueLength(nw*1);
	farm.setOutputQueueLength(nw*1);

	if(notnested) {
		//farm.remove_collector(); // needed to avoid init errors!
		farm.run_and_wait_end();

		// check if ff_nodes need to be deleted
		// in case of nested pattern this don't work - to be fixed with unique_ptr
		//for(int i=0;i<p.num_threads;++i) delete w[i];
	}
}



} // namespace
#endif


#endif /* GRPPI_FF_FARM_H_ */
